<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="DyrE:mG9g%yc$r(m|:tn" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="M}^+ez4j$ci{.9t!qZVz"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace line_tracking_sensor {" line1="    // let mid = 44" line2="    // let lower = 34" line3="    // let upper = 250" line4="" line5="    /**" line6="     * Returns the reflection provided by a MH Sensor connected to the given pin." line7="     * This is a value in [0, 100] where a darker color is closer to 0" line8="     * and a brighter color is closer to 100." line9="     */" line10="    // //% blockId=&quot;reflection&quot;" line11="    // //% block=&quot;reflected light %pin&quot;" line12="    // //% weight=65" line13="    // export function reflection(pin: AnalogPin) {" line14="    //     let reading = Math.constrain(pins.analogReadPin(pin), lower, upper)" line15="    //     if (reading &lt; mid) {" line16="    //         reading = Math.map(reading, lower, mid, 0, 50)" line17="    //     } else {" line18="    //         reading = Math.map(reading, mid, upper, 50, 100)" line19="    //     }" line20="    //     reading = 100 - reading" line21="    //     return reading" line22="" line23="    //     // return Math.round(pins.map(" line24="    //     //     // The sensor never goes below 30 for white. It yields a value" line25="    //     //     // aorund 80 for pretty good black, and can go up to 400 or so" line26="    //     //     // for slightly darker black. A value above 100 is thus as good" line27="    //     //     // as 100. Hence we clip the possible value range to [30, 100]." line28="    //     //     // To follow the convention with Lego where the reflection value" line29="    //     //     // for white is closer to 100 and the value for black is closer" line30="    //     //     // 0, we change the sensor reading to (100 - reading), and scale" line31="    //     //     // the value to [0, 100]" line32="    //     //     100 - Math.max(Math.min(pins.analogReadPin(pin), 100), 30)," line33="    //     //     0," line34="    //     //     70," line35="    //     //     0," line36="    //     //     100" line37="    //     // ))" line38="    // }" line39="    /**" line40="     * Returns the amount of reflected light provided by a MH Sensor connected to" line41="     * the given pin. This is a value in [0, 100] where a darker color is closer to 0" line42="     * and a brighter color is closer to 100." line43="     */" line44="    //% blockId=&quot;reflected_light&quot;" line45="    //% block=&quot;reflected light %pin&quot;" line46="    //% weight=65" line47="    export function reflected_light(pin: AnalogPin) {" line48="        return pins.map(" line49="            100 - Math.max(Math.min(pins.analogReadPin(pin), 100), 40)," line50="            0," line51="            60," line52="            0," line53="            100" line54="        )" line55="    }" line56="}" numlines="57"></mutation></block></statement></block></xml>